let user = {}; // пользователь без адреса
alert( user.address && user.address.street && user.address.street.name ); // undefined (без ошибки)
// Проход при помощи логического оператора И && через весь путь к свойству гарантирует, 
// что все компоненты существуют (если нет, вычисление прекращается), 
// но также не является идеальным.
// Как вы можете видеть, имена свойств по-прежнему дублируются в коде. 
// Например, в приведённом выше коде user.address появляется три раза.
// Вот почему в язык была добавлена опциональная цепочка  ?.. 
// Чтобы решить эту проблему – раз и навсегда!

//  Опциональная цепочка
// Опциональная цепочка ?. останавливает вычисление и возвращает undefined, 
// если значение перед ?. равно undefined или null.
// Далее в этой статье, для краткости, мы будем говорить, 
// что что-то «существует», если оно не является null и не undefined.
// Другими словами, value?.prop:
// работает как value.prop, если значение value существует,
// в противном случае (когда value равно undefined/null) он возвращает undefined.
// Вот безопасный способ получить доступ к user.address.street, используя ?.:
let user = {}; // пользователь без адреса
alert( user?.address?.street ); // undefined (без ошибки)

// Не злоупотребляйте опциональной цепочкой
// Нам следует использовать ?. только там, где нормально, что чего-то не существует.
// К примеру, если, в соответствии с логикой нашего кода, 
// объект user должен существовать, но address является необязательным, 
// то нам следует писать 
// user.address?.street, но не user?.address?.street.
// В этом случае, если вдруг user окажется undefined, 
// мы увидим программную ошибку по этому поводу и исправим её. 
// В противном случае, если слишком часто использовать ?., 
// ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать.